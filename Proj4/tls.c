/*---------------------------------------

			Jenna Zhu
	EC440 - Operating Systems
	Project 4 - Thread Local Storage
	
----------------------------------------*/

#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>
#include <setjmp.h>
#include <signal.h>
#include <semaphore.h>
#include <sys/mman.h>


typedef struct thread_local_storage
{
	pthread_t tid;
	unsigned int size; /* size in bytes */
	unsigned int page_num; /* number of pages */
	struct page **pages; /* array of pointers to pages */
} TLS;


struct page {
	unsigned int address; /* start address of page */
	int ref_count; /* counter for shared pages */
};

typedef struct hash_element
{
	//pthread_t tid;
	TLS *tls;
	struct hash_element *prev;
	struct hash_element *next;
}hash_elmt;

//idunno how id implement a hash table for this project
//so imma use a linked list instead
//struct hash_element* hash_table[HASH_SIZE];

hash_elmt *head;
hash_elmt *end;
int initialized = 0;
int numTLS = 0;
int page_size;

void tls_init();
void tls_handle_page_fault(int sig, siginfo_t *si,void *context);
int tls_create(unsigned	int	size);
int tls_write(unsigned int offset, unsigned int length, char *buffer);
int tls_read(unsigned int	offset,	unsigned int length, char *buffer);
int tls_destroy();
int tls_clone(pthread_t tid);


void tls_init()
{
	struct sigaction sigact;
	/* get the size of a page */
	page_size = getpagesize();
	/* install the signal handler for page faults (SIGSEGV, SIGBUS) */
	sigemptyset(&sigact.sa_mask);
	sigact.sa_flags = SA_SIGINFO; /* use extended signal handling */
	sigact.sa_sigaction = tls_handle_page_fault;
	sigaction(SIGBUS, &sigact, NULL);
	sigaction(SIGSEGV, &sigact, NULL);

	//malloc mem for a head pointer for the linked list of TLSs
	//hash_elmt *firstlistobj = (hash_elmt*)malloc(sizeof(hash_elmt));
	//firstlistobj->next = NULL;
	//head = firstlistobj;

	//change initialized flag to symbolize that TLS has been initialized
	initialized = 1;


	printf("\n TLS initialized \n");
}

void tls_handle_page_fault(int sig, siginfo_t *si, void *context){
	
	int LSApresent = 0;
	int pfaultpresent = 0;

	unsigned int p_fault = ((unsigned int) si->si_addr) & ~(page_size - 1);

	hash_elmt *current = head;
	//loop through the linked list
	while(current->next != NULL){

		current = current->next;
		unsigned int current_page_num = current->tls->page_num;
		int pagecounter;
			
		for(pagecounter = 0; pagecounter < current_page_num; pagecounter++){

			//if it is a seg fault generated by LSA
			if (current->tls->pages[pagecounter]->address == p_fault){
				LSApresent = 0;
				pthread_exit(NULL);
			}

			LSApresent = 1;
		}
		if(LSApresent == 0){
			//otherwise it is a regular seg fault
			signal(SIGSEGV, SIG_DFL);
			signal(SIGBUS, SIG_DFL);
			raise(sig);

		}

		//do this for the other page(s) too

		else{
			int page;
			for(page = 0; page < current->tls->page_num + 1; page++){
				if(current->tls->pages[pagecounter]->address == p_fault){
					pthread_exit(NULL);
					pfaultpresent = 1;
				}
			}
			
			if(pfaultpresent == 0){
			//otherwise it is a regular seg fault
			signal(SIGSEGV, SIG_DFL);
			signal(SIGBUS, SIG_DFL);
			raise(sig);

			}

		}
	}
}

int tls_create (unsigned int size){
	//creates a local storage area (LSA) for the current thread of given size
	//returns 0 on success
	//returns -1 on error (if current thread already has a LSA or if size <= 0)

/*	1. Error handling:
		– check if current thread already has a LSA
		– check size > 0 or not
	2. Allocate TLS using calloc
	3. Initialize TLS,
		– add TLS->threadid,
		– TLS->size and
		– TLS->page_num 
	4. Allocate TLS->pages, array of pointers using calloc
	5. Allocate all pages for this TLS
	6. Add this threadid and TLS mapping to global hash_table	*/

	//if the TLS has not been initialized
	if(!initialized){

		tls_init();

		initialized = 1;

		hash_elmt *init_el = malloc(sizeof(hash_elmt));
		init_el->prev = NULL;
		init_el->next = NULL;
		end = init_el;
		head = init_el;

	}

	if(size < 0){
		printf("\n size of TLS is less than/is 0\n");
		return -1;
	}
	
	hash_elmt *current = head;
	pthread_t current_tid = pthread_self();

	//check if the current thread has a LSA
	while(current->next != NULL){

		current = current->next;
	
		if(current->tls->tid == current_tid){
			printf("\n current thread has no LSA tls_create \n");
			return -1;
		}
	}


	TLS* new = (TLS*)calloc(1, sizeof(TLS));
	printf("\n allocated new TLS \n");
	//set the id
	new->tid = pthread_self();
	//set the size
	new->size = size;
	//find the number of pages in this TLS
	new->page_num = (size - 1)/page_size + 1;
	//create an array for the TLS pages
	new->pages = (struct page**)malloc(sizeof(struct page*) * new->page_num);

	//allocate the TLS pages
	int pagecount = 0; 

	for(pagecount = 0; pagecount < new->page_num; pagecount++){
		//page pointer
		struct page *p;
		p = (struct page*)calloc(1, sizeof(struct page*));
		//create the page
		p->address = (unsigned int)mmap(0, page_size, 0, MAP_ANON | MAP_PRIVATE, 0, 0);
		//page reference count
		p->ref_count = 1;
		//put page into TLS page array
		new->pages[pagecount] = p;

	}
		
		//malloc space and add new TLS to the linked list
		end->next = malloc(sizeof(hash_elmt));
		end->next->tls = new;
		end->next->prev = end;
		end->next->next = NULL;
		hash_elmt *temp = end->next;
		end = temp;

		printf("\n TLS created \n");

		return 0;
	}



int tls_destroy(){
	//frees local storage area for current thread
	//returns 0 on success
	//returns -1 if current thread does not have an LSA

	/*1. Error handling:
		– check if current thread has LSA
	2. Clean up all pages
	3. Clean up TLS
	4. Remove the mapping from hash_table*/

	if(!initialized){
		return -1;
	}

	printf("\n TLS being destroyed \n");

	hash_elmt *current = head;
	pthread_t current_tid = pthread_self();

	//see if the TLS exists
	while(current->next != NULL){

		current = current->next;

		if(current->tls->tid == current_tid){
			printf("\n TLS exists \n");
			break;
		}

		else if(current->next == NULL && current->tls->tid != current_tid){
		//else{
			printf("\n no LSA tls_destroy\n");
			return -1;
		}
	}

	int pageflip;
	unsigned int current_page = current->tls->page_num;
	for(pageflip = 0; pageflip < current_page; pageflip++){

		if(current->tls->pages[pageflip]->ref_count == 1){

			printf("\n found the address \n");
			//unmap the address, delete the page
			munmap((void*)current->tls->pages[pageflip]->address, page_size);
		}

		else{
			//if not found, decrease the ref count
			current->tls->pages[pageflip]->ref_count--;
		}
	}

	/*hash_elmt *delete_me = current
	current = head;

	//loop through your linked list until you find the tls you need to free/destroy
	for(; current->next != delete_me; current = current->next){

			if(current->next == delete_me){

				//move the next pointer to the next TLS after the TLS you want to delete
				current->next = delete_me->next;
			}
	}*/

	//to remove the current item from the linked list
	current->prev->next = current->next;

	if(current->next != NULL){
		current->next->prev = current->prev;
	}

	else{
		end = current->prev;
	}

	printf("\n found the TLS we need to destroy \n");

	//free the TLS page array
	free(current->tls->pages);
	//free the overall TLS
	free(current->tls);
	//free this pointer to reset
	free(current);

	printf("\n TLS destroyed \n");

	return 0;

}

void tls_protect(struct page *p)
{
	printf("\n TLS protected \n");

	if (mprotect((void *) p->address, page_size, 0)) {
		fprintf(stderr, "tls_protect: could not protect page\n");
		exit(1);
	}
}

void tls_unprotect(struct page *p)
{
	printf("\n TLS unprotected \n");

	if (mprotect((void *) p->address, page_size, PROT_READ | PROT_WRITE))
		{
		fprintf(stderr, "tls_unprotect: could not unprotect page\n");
		exit(1);
		}
}

int tls_read(unsigned int offset, unsigned int length, char *buffer){
	//reads length bytes from the LSA of the currently executign thread starting at position offset
	//writes into memory location pointed to by buffer
	//returns 0 on success
	//return -1 on error (if current thread does not have an LSA or if offset+length > size of LSA)

	/* 1. Error handling:
			– check if current thread has a LSA
			– check if offset+length > size
		2. Unprotect all pages belonging to thread’s TLS
		3. Perform read operation
		4. Reprotect all pages belonging to thread’s TLS*/

	if(!initialized){
		printf("\n TLS has not been initialized tls_read\n");
		return -1;
	}

	printf("\n TLS reading \n");

	hash_elmt *current = head;
	pthread_t current_tid = pthread_self();

	while(current->next != NULL){

		current = current->next;

		if(current->tls->tid == current_tid){
			break;
		}
		else if(current->next == NULL && current->tls->tid != current_tid){
			printf("\n current TLS has no LSA tls_read\n");
			return -1;
		}
	}

		if( (offset + length) > current->tls->size){
			printf("\n offset + length > TLS size tls_read\n");
			return -1;
		}

		unsigned int current_page = current->tls->page_num;
		int pagecount;

		for(pagecount = 0; pagecount < current_page; pagecount++){

			tls_unprotect(current->tls->pages[pagecount]);
		}

		printf("\n page num: %d \n", current->tls->page_num);

	int cnt, idx;
	char* src;
	for (cnt = 0, idx = offset; idx < (offset + length); ++cnt, ++idx) {

		printf("\n iteration: %d \n", cnt);

		struct page *p;
		unsigned int pn, poff;
		pn = idx / page_size;
		poff = idx % page_size;
		p = current->tls->pages[pn];
		src = ((char *) p->address) + poff;
		buffer[cnt] = *src;
	}

		for(pagecount = 0; pagecount < current_page; pagecount++){

			tls_protect(current->tls->pages[pagecount]);
		}

	printf("\n TLS read \n");

		return 0;
}


int tls_write(unsigned int offset, unsigned int length, char *buffer){
	//reads length bytes from the memory location pointed to by buffer
	//writes them into a local storage area of the crrently executing thread starting at position offset
	//returns 0 on success
	//returns -1 on error (if current thread does not have an lSA or if offset+length > size of LSA)
	/* 1. Error handling:
		– check if current thread has a LSA
		– check if offset+length > size
		2. Unprotect all pages belonging to thread’s TLS
		3. Perform write operation (next slide)
		4. Reprotect all pages belonging to thread’s TLS*/

	if(!initialized){

		return -1;
	}

	printf("\n TLS writing \n");

	hash_elmt *current = head;
	pthread_t current_tid = pthread_self();

	while(current->next != NULL || current->tls->tid != current_tid){

		current = current->next;

		if(current->tls->tid == current_tid){
			break;
		}

		else if(current->next == NULL && current->tls->tid != current_tid){
			printf("\n current thread does not have a LSA\n");
			return -1;
		}
	}

	if( (offset + length) > current->tls->size){
		printf("\n LSA cant hold offset + length < size of LSA \n");
		return -1;
	}

	unsigned int current_page = current->tls->page_num;
	int pagecount;

	for(pagecount = 0; pagecount < current_page; pagecount++){

		//struct page* unprotected = current->tls->pages[pagecount];
		tls_unprotect(current->tls->pages[pagecount]);
	}

	int cnt, idx;
		/* perform the write operation */
	for (cnt = 0, idx = offset; idx < (offset + length); ++cnt, ++idx) {
	
		struct page *p, *copy;
		unsigned int pn, poff;
		pn = idx / page_size;
		poff = idx % page_size;
		p = current->tls->pages[pn];
		
		if (p->ref_count > 1) {
			/* this page is shared, create a private copy (COW) */
				//create memory space for copy
				copy = (struct page *) calloc(1, sizeof(struct page));
				copy->address = (unsigned int) mmap(0, page_size, PROT_WRITE, MAP_ANON | MAP_PRIVATE, 0, 0);//create the copy page
				printf("[+] allocated %x\n", copy->address);
				copy->ref_count = 1;//set the ref count
				current->tls->pages[pn] = copy;//change the page to the copy page
				
				 /* update original page */

				//int pageend = p->address + page_size;
				int addrcount;
				int copieraddr = copy->address;
				int copiedaddr = p->address;

				for(addrcount = 0; addrcount < page_size; addrcount++){

					//reference the address of the original page with the address of the page you are copying to
					*((char*)copieraddr + addrcount) = *((char*)copiedaddr+addrcount);

				}

				p->ref_count--;
				tls_protect(p);
				p = copy;

			}

		char* dst = ((char *) p->address) + poff;
		*dst = buffer[cnt];

		printf("\n writing: %d \n", *dst);
	}

	for(pagecount = 0; pagecount < current_page; pagecount++)//loop through the page array
	{
		//struct page* unprotected = current->tls->pages[pagecount];
		tls_protect(current->tls->pages[pagecount]);//protect the adress
	}

	printf("\n TLS written \n");

	return 0;

}

int tls_clone(pthread_t tid){
	//clones the LSA of the target thread tid as CoW
		//Copy on Write
			//storage areas of both threads initially refer to the same mem pages
			//only when one thread writes to a shared region then TLS lib creates private copy of the region that is written
			//other areas must remain shared
	//returns 0 on success
	//returns -1 on error (if target thread does not have a LSA, if current thread already has a LSA)

	/*1. Error handling
			– check if current thread already has a LSA
			– check whether target thread has a LSA
		2. Do Cloning, allocate TLS
		3. Copy pages and adjust reference counts
			– Note, per proj. description and CoW semantics do not
		create a copy of the data-pages!
			– Make cloned’ page entries point to original data-pages
			– CoW is handled in tls_write
		4. Add this thread/TLS mapping to global hash_table*/
	if(!initialized){
		return -1;
	}

	printf("\n started cloning \n");

	hash_elmt *current = head;
	pthread_t current_tid = pthread_self();

	//int i;
	//for(i = 0; i < numTLS+1; i++){
	while(current->next != NULL){

		current = current->next;

		printf("\n current: %d \n", (int)current);
		//if current thread does exist (current thread is not supposed to exist)
		if(current->tls->tid == current_tid){
			printf("\n current thread exists LSA \n");

			return -1;
		}

	//	else if(current->next == NULL && current->tls->tid != current_tid){
	//		printf("\n no LSA found tls_clone \n");
	//		return -1;
	//	}
	}


	hash_elmt *targetthread = head;

	//if target thread exists
	while(targetthread->next != NULL){

		targetthread = targetthread->next;

		if(targetthread->tls->tid == tid){
			printf("\n target thread exists\n");
			break;
		}
	}
		//if target thread does not exist
	if(targetthread->next == NULL && targetthread->tls->tid != tid){
		printf("\n target thread does not exist\n");
		return -1;
	}

	//allocate TLS with calloc
	TLS* clone = (TLS*)calloc(1, sizeof(TLS));
	printf("\n allocated TLS clone \n");
	clone->tid = pthread_self();
	clone->page_num = targetthread->tls->page_num;
	clone->size = targetthread->tls->size;
	clone->pages = (struct page**)malloc(sizeof(struct page*) * clone->page_num);

	int pagecnt;
	for(pagecnt = 0; pagecnt < clone->page_num; pagecnt++){
		clone->pages[pagecnt] = targetthread->tls->pages[pagecnt];
		clone->pages[pagecnt]->ref_count++;
	}

	//go to the last one to add it to the TLS linked list to maintain it
	/*current = head; 

    while (current->next != NULL) 
    {
        current = current->next;
    }*/

    //adding the new tls to the linked list
    end->next = malloc(sizeof(hash_elmt));
    end->next->tls = clone;
    end->next->prev = end;
    end->next->next = NULL;
    hash_elmt* temp = end->next;
    end = temp;
	
	printf("\n TLS cloned \n");
    
    return 0;

}